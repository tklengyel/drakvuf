<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>DRAKVUF&trade; Black-box Binary Analysis System</title>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57216990-1', 'auto');
  ga('send', 'pageview');

</script>
  </head>

  <body>
    <header>
      <div class="container">
        <h1>DRAKVUF&trade;</h1>
        <h2>Black-box Binary Analysis System</h2>

        <section id="downloads">
          <a href="https://github.com/tklengyel/drakvuf" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
          <a href="https://github.com/tklengyel/drakvuf/wiki" class="btn">Wiki Documentation</a>
          <a href="https://github.com/tklengyel/drakvuf/tarball/master" class="btn">Download as .tar.gz</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a name="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>DRAKVUF&trade; is a virtualization based agentless black-box binary analysis system. DRAKVUF&trade; allows for in-depth execution tracing of arbitrary binaries (including operating systems), all without having to install any special software within the virtual machine used for analysis.</p>

<p>
<img src="https://travis-ci.org/tklengyel/drakvuf.svg?branch=master">
<a href="https://scan.coverity.com/projects/tklengyel-drakvuf">
  <img alt="Coverity Scan Build Status"
       src="https://scan.coverity.com/projects/3238/badge.svg"/></a>
<img src="https://sonarcloud.io/api/project_badges/measure?project=drakvuf&metric=bugs">
</p>


<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Hardware requirements</h3>
<p>DRAKVUF&trade; uses hardware virtualization extensions found in Intel CPUs. You will need an Intel CPU with virtualization support (VT-x) and with Extended Page Tables (EPT). DRAKVUF&trade; is not going to work on any other CPUs (such as AMD) or on Intel CPUs without the required virtualization extensions.</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Supported guests</h3>
<p>DRAKVUF&trade; currently supports monitoring the following operating systems:
<ul>
<li>Windows 7-8, both 32-bit and 64-bit</li>
<li>Windows 10 64-bit</li>
<li>Linux 2.6.x - 5.x, both 32-bit and 64-bit</li>
</ul>
</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Malware analysis</h3>
<p>DRAKVUF&trade; provides a perfect platform for stealthy malware analysis as its footprint is nearly undectebable from the malware's perspective. While DRAKVUF has been mainly developed with malware analysis in mind, it is certainly not limited to that task as it can be used to monitor the execution of arbitrary binaries.</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Demos</h3>

<p>Using DRAKVUF&trade; to trace Windows internal kernel functions, including heap allocations.</p>

<p><center><iframe width="560" height="315" src="https://www.youtube.com/embed/ZJPHfpDiN4o" frameborder="0" allowfullscreen></iframe></center></p>

<p>This demo shows the process injection component of DRAKVUF&trade; that can start arbitrary executables within the guest, without the aid of any in-guest helper. In the demo we hijack the execution of the standard Windows Task Manager to initiate the execution of our tasks.</p>

<p><center><iframe width="560" height="315" src="https://www.youtube.com/embed/0Dk5RehrA-Q" frameborder="0" allowfullscreen></iframe></center></p>

<p>Extracting deleted files from memory before they are actually discarded by the operating system. Many files created by malware droppes are only present in memory and never show up on disk.</p>

<p><center><iframe width="560" height="315" src="https://www.youtube.com/embed/sOmD9tDU3lM" frameborder="0" allowfullscreen></iframe></center></p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Presentations</h3>

<p>This is a presentation describing the system at the Annual Computer Security Applications Conference (ACSAC) 2014</p>
<p><center><iframe src="https://www.slideshare.net/slideshow/embed_code/42644318" width="476" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe></center></p>

<p>This presentation also describes some of the features of DRAKVUF&trade;, which was released at Hacktivity in 2014</p>
<p><center><iframe width="560" height="315" src="https://www.youtube.com/embed/EZPXy314q3E?rel=0" frameborder="0" allowfullscreen></iframe></center></p>

<p>Our latest talk at Hacktivity 2016 sheds more light on DRAKVUF&trade;'s internals and recent developments</p>
<p><center><iframe width="560" height="315" src="https://www.youtube.com/embed/86EvJK2Ef_U" frameborder="0" allowfullscreen></iframe></center></p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Current status</h3>

<p>Currently the following core features are available:</p>

<ul>
<li>Agentless start of binary execution.</li>
<li>Agentless monitoring of Windows internal kernel functions.</li>
<li>Cloning of analysis VMs via copy-on-write memory and disk.</li>
<li>Guest multi-vCPU support.</li>
</ul>

<p><a href="https://github.com/tklengyel/drakvuf/wiki/DRAKVUF-Plugin-Documentation">Plugins are also available for Windows</a> to monitor several system aspects, for example:</p>

<ul>
<li>Tracing heap allocations.</li>
<li>Tracing files being accessed.</li>
<li>Extracting files from memory before they are deleted.</li>
<li>Tracing UDP and TCP connections</li>
</ul>

<p>There are many opportunities to improve and extend DRAKVUF&trade;. Take a look at our <a href="https://github.com/tklengyel/drakvuf/issues">Issues page</a> and also, just to name a few more:</p>

<ul>
<li>Structured logging into MySQL/MongoDB.</li>
<li>Automatic submission of extracted files to VirusTotal.</li>
<li>Run-time deduplication of unused memory with Xen's memory sharing.</li>
<li>Integration into malware analysis operations, such as <a href="https://holmesprocessing.github.io">HOLMES</a>.</li>
</ul>

<p>As DRAKVUF&trade; is an open-source project, patches and bug reports are always welcome on the <a href="https://github.com/tklengyel/drakvuf">Github page</a>! More information can be found in the <a href="https://github.com/tklengyel/drakvuf/wiki">DRAKVUF&trade; Wiki</a> about working with the project.</p>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Installation guide</h3>
<p><b>UPDATED 10/10/2019</b> DRAKVUF&trade; now runs best on Xen 4.12.1</p>

<p>The system has been mainly tested on Debian Buster and Ubuntu 18.04 LTS. You can find pre-built debian packages of the latest DRAKVUF builds at <a href="https://github.com/tklengyel/drakvuf-builds/releases">https://github.com/tklengyel/drakvuf-builds/releases</a></p>

<p>To build DRAKVUF&trade; from source the following packages are normally required Debian based Linux distros.</p>

<pre><code>sudo apt-get install wget git bcc bin86 gawk bridge-utils iproute2 libcurl4-openssl-dev bzip2 pciutils-dev build-essential make gcc clang libc6-dev libc6-dev-i386 linux-libc-dev zlib1g-dev libncurses5-dev patch libvncserver-dev libssl-dev libsdl-dev iasl libbz2-dev e2fslibs-dev git-core uuid-dev ocaml libx11-dev bison flex ocaml-findlib xz-utils gettext libyajl-dev libpixman-1-dev libaio-dev libfdt-dev cabextract libglib2.0-dev autoconf automake libtool libjson-c-dev libfuse-dev liblzma-dev autoconf-archive kpartx python-dev
</code></pre>

<pre><code>cd ~
git clone https://github.com/tklengyel/drakvuf
cd drakvuf
git submodule init
git submodule update
cd xen
./configure --enable-githttp --disable-pvshim
make -j4 dist-xen
make -j4 dist-tools
</code></pre>

To install Xen with dom0 getting 4GB RAM assigned and two dedicated CPU cores (tune it as preferred):

<pre><code>sudo su
make -j4 install-xen
make -j4 install-tools
echo "GRUB_CMDLINE_XEN_DEFAULT=\"dom0_mem=4096M,max:4096M dom0_max_vcpus=4 dom0_vcpus_pin=1 force-ept=1 ept=pml=0 hap_1gb=0 hap_2mb=0 altp2m=1 smt=0\"" >> /etc/default/grub
echo "/usr/local/lib" > /etc/ld.so.conf.d/xen.conf
ldconfig
echo "none /proc/xen xenfs defaults,nofail 0 0" >> /etc/fstab
echo "xen-evtchn" >> /etc/modules
echo "xen-privcmd" >> /etc/modules
update-rc.d xencommons defaults 19 18
</code></pre>

Once you are done with these steps, you can finalize your setup:

<pre><code>update-grub
reboot
</code></pre>

<p>Also make sure you are running a relatively recent kernel (anything above 3.8 should just work).</p>

<pre><code>uname -r</code></pre>

Once you are booted into Xen, verify that everything works as such:
<pre><code>sudo xen-detect</code></pre>

The output should be: Running in PV context on Xen

<pre><code>xl list</code></pre>

The output should be something similar:
<pre><code>Name                                        ID   Mem VCPUs	State	Time(s)
Domain-0                                     0  4096     2     r-----     614.0
</code></pre>

Setup an LVM Volume Group to hold your VMs disks (<a href="https://www.howtoforge.com/linux_lvm">see this tutorial for help</a>), then create a volume:

<pre><code>lvcreate -L20G -n windows7-sp1 vg</code></pre>

Install Windows 7 from your ISO using the following template (tune it as needed):
<pre><code>arch = 'x86_64'
name = "windows7-sp1"
maxmem = 3000
memory = 3000
vcpus = 2
maxcpus = 2
builder = "hvm"
boot = "cd"
hap = 1
acpi = 1
on_poweroff = "destroy"
on_reboot = "destroy"
on_crash = "destroy"
vnc=1
vnclisten="0.0.0.0"
usb = 1
usbdevice = "tablet"
altp2m = 2
shadow_memory = 16
audio=1
soundhw='hda'
vif = [ 'type=ioemu,model=e1000,bridge=xenbr0,mac=00:06:5B:BA:7C:01' ]
disk = [ 'phy:/dev/vg/windows7-sp1,hda,w', 'file:/path/to/your/windows7.iso,hdc:cdrom,r' ]
</pre></code>

Enter the LibVMI folder in the drakvuf folder and build it:

<pre><code>cd ~/drakvuf/libvmi
cmake -DENABLE_KVM=OFF -DENABLE_FILE=OFF -DENABLE_BAREFLANK=OFF .
make
sudo make install
sudo echo "export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/lib" >> ~/.bashrc
</code></pre>

Rekall is unfortunately buggy with newer versions of Python3 so we have to stick to Python 3.5.7:

<pre><code>wget https://www.python.org/ftp/python/3.5.7/Python-3.5.7.tar.xz
tar xvf Python-3.5.7.tar.xz
cd Python-3.5.7
./configure --enable-optimizations --prefix=/opt/python3.5.7
sudo make altinstall
cd ..
</code></pre>

Now lets make Python 3 the default and install some required packages:

<pre><code>sudo update-alternatives --install /usr/bin/python python /opt/python3.5.7/bin/python3.5 1
sudo /opt/python3.5.7/bin/pip3.5 install fastchunking wheel future==0.16.0
</code></pre>

Install Rekall from the submodule:

<pre><code>cd rekall/rekall-core
./setup.py build
sudo ./setup.py install
</code></pre>

Now we will create the Rekall profile for the Windows domain. First, we need to get the debug information for the Windows kernel via the LibVMI vmi-win-guid tool. For example, in the following my domain is named windows7-sp1-x86:

<pre><code>$ sudo xl list
Name                                        ID   Mem VCPUs	State	Time(s)
Domain-0                                     0  4024     4     r-----     848.8
windows7-sp1-x86                             7  3000     1     -b----      94.7
$ sudo vmi-win-guid name windows7-sp1-x86
Windows Kernel found @ 0x2604000
	Version: 32-bit Windows 7
	PE GUID: 4ce78a09412000
	PDB GUID: 684da42a30cc450f81c535b4d18944b12
	Kernel filename: ntkrpamp.pdb
	Multi-processor with PAE (version 5.0 and higher)
	Signature: 17744.
	Machine: 332.
	# of sections: 22.
	# of symbols: 0.
	Timestamp: 1290242569.
	Characteristics: 290.
	Optional header size: 224.
	Optional header type: 0x10b
	Section 1: .text
	Section 2: _PAGELK
	Section 3: POOLMI
	Section 4: POOLCODE
	Section 5: .data
	Section 6: ALMOSTRO
	Section 7: SPINLOCK
	Section 8: PAGE
	Section 9: PAGELK
	Section 10: PAGEKD
	Section 11: PAGEVRFY
	Section 12: PAGEHDLS
	Section 13: PAGEBGFX
	Section 14: PAGEVRFB
	Section 15: .edata
	Section 16: PAGEDATA
	Section 17: PAGEKDD
	Section 18: PAGEVRFC
	Section 19: PAGEVRFD
	Section 20: INIT
	Section 21: .rsrc
	Section 22: .reloc
</code></pre>

The important fields are:
<pre><code>PDB GUID: 684da42a30cc450f81c535b4d18944b12
Kernel filename: ntkrpamp.pdb
</code></pre>

If vmi-win-guid fails to find the Windows kernel in memory, you can use Rekall to examine ntoskrnl.exe on the disk:
<pre><code>sudo su
kpartx -a /dev/vg/windows7
mount -o ro /dev/vg/windows7p1 /mnt
python3 rekal peinfo -f /mnt/Windows/System32/ntoskrnl.exe > /tmp/peinfo.txt
umount /mnt
kpartx -d /dev/vg/windows7
</code></pre>

The generated /tmp/peinfo.txt file will contain the required PDB filename and GUID.

Now generate the Rekall profile (make sure to adjust the kernel name and GUID as necessary):
<pre><code>cd /tmp
python3 rekall fetch_pdb ntkrpamp 684da42a30cc450f81c535b4d18944b12
python3 rekall parse_pdb ntkrpamp > windows7-sp1.rekall.json
sudo mv windows7-sp1.rekall.json /root
</code></pre>

With this profile ready we can create the LibVMI config:
<pre><code>sudo su
printf "windows7-sp1 { \n\
    ostype = \"Windows\"; \n\
    rekall_profile = \"/root/windows7-sp1.rekall.json\"; \n\
}" >> /etc/libvmi.conf
exit
</code></pre>

Test if LibVMI is working by running vmi-process-list:
<pre><code>sudo vmi-process-list windows7-sp1</code></pre>

Output should be something similar:
<pre><code>Process listing for VM windows7-sp1-x86 (id=7)
[    4] System (struct addr:84aba980)
[  220] smss.exe (struct addr:85a44020)
[  300] csrss.exe (struct addr:85f67a68)
[  336] wininit.exe (struct addr:8601e030)
[  348] csrss.exe (struct addr:84ba4030)
[  384] winlogon.exe (struct addr:85966d40)
[  444] services.exe (struct addr:8614c030)
[  460] lsass.exe (struct addr:86171030)
[  468] lsm.exe (struct addr:8617b4f8)
[  564] svchost.exe (struct addr:861d9bc8)
[  628] svchost.exe (struct addr:863fb8a8)
[  816] sppsvc.exe (struct addr:86426838)
[  856] svchost.exe (struct addr:854abd40)
[  880] svchost.exe (struct addr:854c5030)
[  916] svchost.exe (struct addr:854d7a70)
[ 1240] svchost.exe (struct addr:8614cb80)
[ 1280] svchost.exe (struct addr:854f7d40)
[ 1608] spoolsv.exe (struct addr:85578660)
[ 1636] svchost.exe (struct addr:85554af0)
[  792] SearchIndexer. (struct addr:8562ac08)
[ 1128] taskhost.exe (struct addr:858d9d40)
[ 1524] dwm.exe (struct addr:857f3a60)
[ 1728] explorer.exe (struct addr:858d9180)
[ 1720] regsvr32.exe (struct addr:8605f398)
[  248] svchost.exe (struct addr:863ed030)
[ 1024] svchost.exe (struct addr:86420390)
[  256] WmiPrvSE.exe (struct addr:854014a0)
</code></pre>

For Linux you need to build the initial kernel profile in the guest itself.
<pre><code>ssh root@linux
apt-get install git zip linux-headers-$(uname -r) build-essential
git clone --depth=1 https://github.com/google/rekall
cd rekall/tools/linux
make
</code></pre>

This will generate a ZIP file with your kernel-version as filename. For example, 3.16.0-4-amd64.zip. Copy this file to your DRAKVUF&trade; host (for example using scp). There we will convert it to the proper JSON Rekall profile.
<pre><code>rekal convert_profile 3.16.0-4-amd64.zip /root/linux.json
sudo printf "linux { \n\
    ostype = \"Linux\"; \n\
    rekall_profile = \"/root/linux.json\"; \n\
}" >> /etc/libvmi.conf
</code></pre>

Now running vmi-process-list should show a similar output:
<pre><code>sudo vmi-process-list linux
Process listing for VM linux (id=29)
[    0] swapper/0 (struct addr:ffffffff8181a460)
[    1] systemd (struct addr:ffff88007b3a92b0)
[    2] kthreadd (struct addr:ffff88007b3a8960)
[    3] ksoftirqd/0 (struct addr:ffff88007b3a8010)
[    5] kworker/0:0H (struct addr:ffff88007a8109a0)
[    6] kworker/u2:0 (struct addr:ffff88007a810050)
[    7] rcu_sched (struct addr:ffff88007a847330)
[    8] rcu_bh (struct addr:ffff88007a8469e0)
[    9] migration/0 (struct addr:ffff88007a846090)
[   10] watchdog/0 (struct addr:ffff88007a85f370)
[   11] khelper (struct addr:ffff88007a85ea20)
[   12] kdevtmpfs (struct addr:ffff88007a85e0d0)
[   13] netns (struct addr:ffff88007a8d13b0)
[   14] xenwatch (struct addr:ffff88007a8d0a60)
[   15] xenbus (struct addr:ffff88007a8d0110)
[   17] khungtaskd (struct addr:ffff88007a902aa0)
[   18] writeback (struct addr:ffff88007a902150)
[   19] ksmd (struct addr:ffff88007a935430)
[   20] khugepaged (struct addr:ffff88007a934ae0)
[   21] crypto (struct addr:ffff88007a934190)
[   22] kintegrityd (struct addr:ffff88007a93f470)
[   23] bioset (struct addr:ffff88007a93eb20)
[   24] kblockd (struct addr:ffff88007a93e1d0)
[   25] kswapd0 (struct addr:ffff8800776d34b0)
[   26] vmstat (struct addr:ffff8800776d2b60)
[   27] fsnotify_mark (struct addr:ffff8800776d2210)
[   33] kthrotld (struct addr:ffff88007770c290)
</code></pre>

Now we are ready to build and install DRAKVUF&trade;:
<pre><code>cd ~/drakvuf
autoreconf -vi
./configure
make
</code></pre>

To simply trace the execution of the system:
<pre><code>sudo ./src/drakvuf -r &lt;rekall profile&gt; -d &lt;domid&gt;</code></pre>

For example:
<pre><code>sudo ./src/drakvuf -r /root/windows7-sp1.rekall.json -d 7</code></pre>

To see all available options:
<pre><code>./src/drakvuf</code></pre>

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Optional: Generate usermode profiles</h3>

DRAKVUF&trade; has some enhanced functionality which can be enabled by providing necessary Rekall profiles for particular <code>.dll</code> or <code>.sys</code> files. For instance, network monitoring plugin (socketmon) requires the creation of a Rekall profile for the <code>tcpip.sys</code> kernel module, which is normally located at <code>C:\Windows\System32\drivers\tcpip.sys</code>. You will need to copy this file to where you will be generating the Rekall profile at. To generate a Rekall profile for it you can use the <code>pdbparse</code> project to obtain the PDB:

<pre><code>apt-get install python-construct python-pefile
git clone https://github.com/moyix/pdbparse
cd pdbparse
python setup.py build
cd examples
./symchk.py -e tcpip.sys</code></pre>

Then you can use Rekall to create the profile:

<pre><code>rekall parse_pdb tcpip.pdb &gt; tcpip.json</code></pre>

You should provide the path to the profile by using DRAKVUF&trade;'s <code>-T</code> or <code>--rekall-tcpip</code> command line option. Type <code>drakvuf --help</code> in order to display the list of auxilary Rekall profiles that are accepted by DRAKVUF&trade; and the corresponding command line options.

<h3>
<a name="designer-templates" class="anchor" href="#designer-templates"><span class="octicon octicon-link"></span></a>Citation</h3>

If you use DRAKVUF&trade; in an academic project, please cite using the following bibtex key:

<pre><code>@inproceedings{lengyel2014drakvuf,
  author = {Lengyel, Tamas K. and Maresca, Steve and Payne, Bryan D. and Webster, George D. and Vogl, Sebastian and Kiayias, Aggelos},
  title = {Scalability, Fidelity and Stealth in the DRAKVUF Dynamic Malware Analysis System},
  booktitle = {Proceedings of the 30th Annual Computer Security Applications Conference},
  year = {2014}
}
</code></pre>

      </section>
    </div>    
  </body>
</html>
